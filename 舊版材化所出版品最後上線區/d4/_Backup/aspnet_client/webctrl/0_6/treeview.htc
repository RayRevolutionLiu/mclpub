<!--
Copyright (c) 2000-2001 Microsoft Corp. All rights reserved.
Version 0.6.1.626
-->

<public:component tagname=treeview literalcontent=true>
<public:attach event=oncontentready onevent="oncontentready()" />
<public:attach event=ondocumentready onevent="ondocumentready()" />
<public:event name="onexpand" id="_tvevtExpand" />
<public:event name="oncollapse" id="_tvevtCollapse" />
<public:event name="onselectedindexchanged" id="_tvevtSelect" />
<public:event name="oncheck" id="_tvevtCheck" />
<public:event name="onfirequeuedevents" id="_tvevtFireQueuedEvents" />
<public:event name="ondatasetcomplete" id="_tvevtDataSetComplete" />
<public:property name="clickedNodeIndex" GET="getClickedNodeIndex" />
<public:property name="defaultStyle" id="_tvpropDefaultStyle" GET="getDefaultStyle" PUT="setDefaultStyle" />
<public:property name="hoverStyle" id="_tvpropHoverStyle" GET="getHoverStyle" PUT="setHoverStyle" />
<public:property name="selectedStyle" id="_tvpropSelectedStyle" GET="getSelectedStyle" PUT="setSelectedStyle" />
<public:property name="childType" id="_tvpropChildType" GET="getChildType" PUT="setChildType" />
<public:property name="imageUrl" id="_tvpropImageUrl" GET="getImageUrl" PUT="setImageUrl" />
<public:property name="expandedImageUrl" id="_tvpropExpandedImageUrl" GET="getExpandedImageUrl" PUT="setExpandedImageUrl" />
<public:property name="selectedImageUrl" id="_tvpropSelectedImageUrl" GET="getSelectedImageUrl" PUT="setSelectedImageUrl" />
<public:property name="target" id="_tvpropTarget" GET="getTarget" PUT="setTarget" />
<public:property name="treeNodeSrc" id="_tvpropTreeNodeSrc" GET="getTreeNodeSrc" PUT="setTreeNodeSrc" />
<public:property name="treeNodeXslSrc" id="_tvpropTreeNodeXslSrc" GET="getTreeNodeXslSrc" PUT="setTreeNodeXslSrc" />
<public:property name="selectExpands" id="_tvpropSelectExpands" GET="getSelectExpands" PUT="setSelectExpands" />
<public:property name="expandLevel" id="_tvpropExpandLevel" GET="getExpandLevel" PUT="setExpandLevel" />
<public:property name="autoSelect" id="_tvpropAutoSelect" GET="getAutoSelect" PUT="setAutoSelect" />
<public:property name="treeNodeTypeSrc" id="_tvpropTreeNodeTypeSrc" GET="getTreeNodeTypeSrc" PUT="setTreeNodeTypeSrc" />
<public:property name="showLines" id="_tvpropShowLines" GET="getShowLines" PUT="setShowLines" />
<public:property name="showPlus" id="_tvpropShowPlus" GET="getShowPlus" PUT="setShowPlus" />
<public:property name="indent" id="_tvpropIndent" GET="getIndent" PUT="setIndent" />
<public:property name="selectedNodeIndex" id="_tvpropSelectedNodeIndex" GET="getSelectedNodeIndex" PUT="setSelectedNodeIndex" />
<public:property name="systemImagesPath" id="_tvpropSystemImagesPath" GET="getSystemImagesPath" PUT="setSystemImagesPath" />
<public:method name="queueEvent" />
<public:method name="getTreeNode" />
<public:method name="addAt" />
<public:method name="createTreeNode" />
<public:method name="getTreeNodeType" />
<public:method name="createTreeNodeType" />
<public:method name="addTreeNodeType" />
<public:method name="add" />
</public:component>
<script language=javascript>
var contentNode;
var treeviewNode;
var typesNode;
var g_styles;
var g_event;
var g_timer = -1;
var g_nodeClicked = null;
var g_strQueuedEvents = "";
var g_bInteractive = false;
var g_selectedNodeBeforeDelay = "";
var g_focusTimeout = 100;
var g_bFocus = false;
var g_bCreated = false;
var g_databindInfo = new Object();
var g_typeIsland = null;
var g_bNodesReady = false;
var g_bTypesReady = false;
var g_bMouseDown = false;
var g_delayPending = false;
var prop_defaultStyle = null;
var prop_hoverStyle = null;
var prop_selectedStyle = null;
var prop_childType = null;
var prop_imageUrl = null;
var prop_expandedImageUrl = null;
var prop_selectedImageUrl = null;
var prop_target = null;
var prop_treeNodeSrc = null;
var prop_treeNodeXslSrc = null;
var prop_selectExpands = null;
var prop_expandLevel = -1;
var prop_autoSelect = false;
var prop_treeNodeTypeSrc = null;
var prop_showLines = true;
var prop_showPlus = true;
var prop_indent = 19;
var prop_selectedNodeIndex = null;
var prop_systemImagesPath = null;
function queueEvent(strEvent, strParams)
{
if (g_strQueuedEvents.length > 0)
g_strQueuedEvents += ";";
g_strQueuedEvents += (strEvent + "," + strParams);
setHiddenHelperValue();
}
function getQueuedEvents()
{
return g_strQueuedEvents;
}
function fireQueuedEvents()
{
if (g_strQueuedEvents != "")
{
if (getAttribute("onfirequeuedevents") != null)
{
if (g_timer != -1)
{
window.clearTimeout(g_timer);
autoSelect();
}
else
{
g_bInteractive = false;
_tvevtFireQueuedEvents.fire();
}
}
}
}
function SetAnchorClass(node, name)
{
var strStyle = "";
var lname = name.toLowerCase();
strStyle += cascadeStyle(getParentTreeNode(node), "defaultstyle");
if (lname != "defaultstyle")
{
var str = cascadeStyle(getParentTreeNode(node), lname);
if (str != null)
{
strStyle += ";" + str;
}
}
node.style.cssText = strStyle;
if (lname == "hoverstyle" && g_bFocus == false)
blurFilter(node);
node.className = lname;
}
function getParentTreeNode(node)
{
var el = node;
while (el != null && el.getAttribute("treenode") == null)
el = el.parentElement;
return el.getAttribute("treenode");
}
function HoverNode(textnode)
{
if (g_bInteractive == true)
{
var node;
if (textnode.tagName.toLowerCase() == "treenode")
node = textnode.subtree.all.item("_tntext", 0);
else
node = textnode;
if (node.className == "defaultstyle")
{
SetAnchorClass(node, "hoverstyle");
HoverNodeIndex = getNodeIndex(getParentTreeNode(node));
}
else if (node.className != "hoverstyle")
HoverNodeIndex = "";
setHiddenHelperValue();
}
}
function UnhoverNode(textnode)
{
if (textnode != null && g_bInteractive == true)
{
var node;
if (textnode.tagName.toLowerCase() == "treenode")
node = textnode.subtree.all.item("_tntext", 0);
else
node = textnode;
if (node.className == "hoverstyle")
SetAnchorClass(node, "defaultstyle");
HoverNodeIndex = "";
setHiddenHelperValue();
}
}
function mOver()
{
var oItem = this.all.item("_tntext", 0);
if (HoverNodeIndex.length > 0)
UnhoverNode(getNodeFromIndex(HoverNodeIndex));
HoverNode(oItem);
event.cancelBubble = true;
}
function mOut()
{
var oItem = this.all.item("_tntext", 0);
UnhoverNode(oItem);
event.cancelBubble = true;
}
function onkeydown()
{
if (!g_bInteractive)
return;
var oldNode;
var hoverNode = null;
if (HoverNodeIndex.length > 0)
{
oldNode = getNodeFromIndex(HoverNodeIndex);
hoverNode = oldNode;
}
else
oldNode = getNodeFromIndex(selectedNodeIndex);
switch (event.keyCode)
{
case 187:
if (event.shiftKey != true)
break;
case 107:
if (oldNode.getAttribute("expanded") != true)
{
doNodePlusMinusClick(oldNode);
fireQueuedEvents();
}
event.returnValue = false;
break;
case 189:
if (event.shiftKey == true)
break;
case 109:
if (oldNode.getAttribute("expanded") == true)
{
doNodePlusMinusClick(oldNode);
fireQueuedEvents();
}
event.returnValue = false;
break;
case 39:
event.returnValue = false;
if (oldNode.children.tags("treenode").length == 0)
{
var exp = getNodeAttribute(oldNode, "expandable");
if (exp == null && oldNode.getAttribute("TreeNodeSrc") != null)
exp = "checkOnce";
if (oldNode.getAttribute("expanded") == true || !(exp == "always" || (exp == "checkOnce" && oldNode.getAttribute("checkedExpandable") != true)))
break;
}
if (oldNode.getAttribute("expanded") != true)
{
doNodePlusMinusClick(oldNode);
HoverNode(oldNode);
updateStatus(oldNode);
fireQueuedEvents();
break;
}
case 40:
var node = getNextVisibleNode(oldNode);
if (node != null)
{
if (element.getAttribute("autoselect") == true)
{
selectNode(node, true);
updateStatus(node);
UnhoverNode(hoverNode);
}
else
{
UnhoverNode(oldNode);
HoverNode(node);
updateStatus(node);
}
scrollTree(node);
}
event.returnValue = false;
break;
case 37:
if (oldNode.getAttribute("expanded") == true)
{
doNodePlusMinusClick(oldNode);
fireQueuedEvents();
}
else
{
var node = oldNode.parentElement;
while (node.tagName.substr(0,4).toLowerCase() != "tree")
node = node.parentElement;
if (node.tagName.toLowerCase() == "treenode")
{
if (element.getAttribute("autoselect") == true)
{
selectNode(node, true);
updateStatus(node);
UnhoverNode(hoverNode);
}
else
{
UnhoverNode(oldNode);
HoverNode(node);
updateStatus(node);
}
scrollTree(node);
}
}
event.returnValue = false;
break;
case 38:
var node = getPreviousVisibleNode(oldNode);
if (node != null)
{
if (element.getAttribute("autoselect") == true)
{
selectNode(node, true);
updateStatus(node);
UnhoverNode(hoverNode);
}
else
{
UnhoverNode(oldNode);
HoverNode(node);
updateStatus(node);
}
scrollTree(node);
}
event.returnValue = false;
break;
case 32:
case 13:
doNodeClick(oldNode)
if (!navigateNode(oldNode))
{
if (element.getAttribute("selectExpands") == true)
doNodePlusMinusClick(oldNode);
fireQueuedEvents();
}
event.returnValue = false;
break;
}
}
function updateStatus(node)
{
var href = node.getAttribute("navigateurl");
if (href != null)
window.status = href;
else
window.status = "";
}
function onstop()
{
g_bInteractive = true;
if (g_databindInfo != null && g_databindInfo.el != null)
g_databindInfo.el._bound = null;
}
function onfocus()
{
g_bFocus = true;
window.setTimeout(dofocus, g_focusTimeout, "JScript");
}
function dofocus()
{
g_bFocus = true;
node = getNodeFromIndex(selectedNodeIndex);
if (node != null)
{
var oItem = node.subtree.all.item("_tntext", 0);
if (oItem != null)
{
if (g_bInteractive)
focusFilter(oItem);
oItem.tabIndex = 1;
if (!g_bMouseDown)
{
try
{
oItem.focus();
}
catch (e)
{
}
}
g_focusTimeout = 10;
}
}
node = getNodeFromIndex(HoverNodeIndex);
if (node != null && g_bInteractive)
{
var oItem = node.subtree.all.item("_tntext", 0);
if (oItem != null)
focusFilter(oItem);
}
}
function focusFilter(oItem)
{
if (oItem.filters.length > 0)
{
var oFilter = oItem.filters.item("DXImageTransform.Microsoft.Alpha");
if (oFilter)
{
oFilter.opacity *= 2;
}
}
}
function onblur()
{
g_bFocus = false;
var node = getNodeFromIndex(selectedNodeIndex);
if (node != null)
{
var oItem = node.subtree.all.item("_tntext", 0);
blurFilter(oItem);
oItem.tabIndex = -1;
}
node = getNodeFromIndex(HoverNodeIndex);
if (node != null)
{
var oItem = node.subtree.all.item("_tntext", 0);
blurFilter(oItem);
oItem.tabIndex = -1;
}
setHiddenHelperValue();
}
function blurFilter(oItem)
{
if (oItem.filters.length > 0)
{
var oFilter = oItem.filters.item("DXImageTransform.Microsoft.Alpha");
if (oFilter)
{
oFilter.opacity /= 2;
return;
}
}
oItem.style.filter += "progid:DXImageTransform.Microsoft.Alpha(opacity=50,style=0)";
}
function oncontentready()
{
if (element.document.parentWindow.name == "__hifSmartNav")
return;
g_styles = new Object();
g_styles["parent"] = "font: 10pt Times; text-decoration: none; color: black; overflow:hidden;";
g_styles["child"] = "font: 10pt Times; overflow:hidden;";
g_styles["defaultstyle"] = "display:inline; height=100%; font: 10pt Times; color: black; text-decoration:none; cursor: hand; overflow:hidden;";
g_styles["hoverstyle"] = "color: highlighttext; background-color:highlight; filter:progid:DXImageTransform.Microsoft.Alpha(opacity=50,style=0);";
g_styles["selectedstyle"] = "color: highlighttext; background-color:highlight;";
g_styles["icon"] = "margin-right: 5; cursor:hand;";
if (element.style.overflowX == "");
element.style.overflowX = "auto";
verifyBooleanAttribute(element, "showPlus");
if (element.getAttribute("showPlus") == false && element.getAttribute("selectExpands") == null)
element.setAttribute("selectExpands", true, 0);
verifyBooleanAttribute(element, "selectExpands");
verifyBooleanAttribute(element, "autoSelect");
verifyBooleanAttribute(element, "showLines");
var systemImagesPath = element.getAttribute("SystemImagesPath");
if (systemImagesPath == null)
element.setAttribute("SystemImagesPath", "treeimages/", 0);
else if (systemImagesPath.charAt(systemImagesPath.length - 1) != '/')
element.setAttribute("SystemImagesPath", systemImagesPath + '/', 0);
contentNode = element.document.createElement("treeview");
contentNode.innerHTML = element.innerHTML;
element.tabIndex=0;
element.attachEvent("onkeydown", onkeydown);
element.attachEvent("onfocus", onfocus);
element.attachEvent("onblur", onblur);
element.document.attachEvent("onstop", onstop);
element.hideFocus = true;
if (element.getAttribute("selectedNodeIndex") == null)
prop_selectedNodeIndex = "";
if (element.getAttribute("HoverNodeIndex") == null)
element.setAttribute("HoverNodeIndex", "", 0);
if (element.getAttribute("TreeNodeTypeSrc") == null)
{
element.nodeTypes = contentNode.children.tags("TREENODETYPE");
verifyTypeValues();
g_bTypesReady = true;
}
else
databindTypes();
if (treeNodeSrc != null)
{
if (element.nodeTypes != null)
{
contentNode.innerHTML = getNodeTypeHtml();
element.nodeTypes = contentNode.children.tags("TREENODETYPE");
}
else
contentNode.innerHTML = "";
databindNode(element);
}
else
{
g_bNodesReady = true;
tryToBuildTreeFromRoot();
}
}
function ondocumentready()
{
if (element.document.parentWindow.name == "__hifSmartNav")
return;
g_strQueuedEvents = "";
if (prop_selectedNodeIndex.length == 0)
{
prop_selectedNodeIndex = "0";
}
var node = getNodeFromIndex(selectedNodeIndex);
prop_selectedNodeIndex = "";
selectNode(node);
if (HoverNodeIndex.length > 0)
HoverNode(getNodeFromIndex(HoverNodeIndex));
if (element.getAttribute("Focused") != null)
dofocus();
else
onblur();
g_bInteractive = true;
}
function changeIcon(node, imageUrl)
{
var imageUrlLC = imageUrl.toLowerCase();
var icon1 = node.subtree.all("_tntext",0).previousSibling;
if (icon1 != null && icon1.name != "nodeicon")
icon1 = null;
var newSrc = getNodeAttribute(node, imageUrlLC);
if (newSrc != null && icon1 == null)
{
icon1 = node.document.createElement("<IMG style='margin-right:5' align='absmiddle' border='0' class='icon' name='nodeicon' >");
icon1.src = newSrc;
var textnode = node.subtree.all("_tntext", 0);
textnode.parentElement.insertBefore(icon1, textnode);
}
else if (newSrc != null)
{
icon1.src = newSrc;
icon1.style.display = "inline";
}
else if (imageUrlLC == "imageurl")
{
if (icon1 != null)
{
icon1.style.display = "none";
}
}
else if (imageUrlLC == "selectedimageurl" && node.getAttribute("expanded") == true)
changeIcon(node, "expandedimageurl");
else
changeIcon(node, "imageurl");
}
function selectNode(node, delay)
{
var nodeIndex = getNodeIndex(node);
var selectedNode = null;
var strImage;
var oItem;
var oOldItem = null;
if (selectedNodeIndex != nodeIndex)
{
if (selectedNodeIndex.length > 0)
{
selectedNode = getNodeFromIndex(selectedNodeIndex);
if (selectedNode != null)
{
oOldItem = selectedNode.subtree.all.item("_tntext", 0);
SetAnchorClass(oOldItem, "defaultstyle");
oOldItem.tabIndex = -1;
if (selectedNode.getAttribute("expanded") == true)
strImage = "ExpandedImageUrl";
else
strImage = "ImageUrl";
changeIcon(selectedNode, strImage);
}
}
oItem = node.subtree.all.item("_tntext", 0);
applySelection(node, oItem);
if (selectedNodeIndex.length > 0)
{
g_event = createEventObject();
g_event.newnodeIndex = nodeIndex;
g_event.oldnodeIndex = selectedNodeIndex;
if (delay != true)
_tvevtSelect.fire(g_event);
else
{
if (g_timer != -1)
window.clearTimeout(g_timer);
g_timer = window.setTimeout(autoSelect, 500, "JScript");
if (g_selectedNodeBeforeDelay == "")
g_selectedNodeBeforeDelay = selectedNodeIndex;
}
}
prop_selectedNodeIndex = nodeIndex;
if (!g_bFocus && g_bInteractive)
{
if (oOldItem != null)
focusFilter(oOldItem);
}
}
setHiddenHelperValue();
}
function autoSelect()
{
g_timer = -1;
if (selectedNodeIndex != g_selectedNodeBeforeDelay)
{
navigateNode(getNodeFromIndex(g_event.newnodeIndex));
_tvevtSelect.fire(g_event);
fireQueuedEvents();
}
g_selectedNodeBeforeDelay = "";
}
function applySelection(node, oItem)
{
SetAnchorClass(oItem, "SelectedStyle");
changeIcon(node, "SelectedImageUrl");
oItem.tabIndex = 1;
scrollTree(node);
if (selectedNodeIndex.length > 0)
{
var activeEl = element.document.activeElement;
if (activeEl != null && activeEl.id == id)
oItem.focus();
}
if (!g_bFocus && g_bInteractive)
{
if (g_delayPending != true)
{
g_delayPending = true;
window.setTimeout(delayedBlur, 100, "JScript");
}
}
}
function delayedBlur()
{
var node = getNodeFromIndex(selectedNodeIndex);
var oItem = node.subtree.all.item("_tntext", 0);
blurFilter(oItem);
g_delayPending = false;
}
function reselectNode(el)
{
if (selectedNodeIndex == getNodeIndex(el))
applySelection(el, el.subtree.all.item("_tntext", 0));
}
function tryToBuildTreeFromRoot()
{
if (g_bNodesReady == true && g_bTypesReady == true)
{
var bRebuilding = g_bCreated;
buildTreeFromRoot();
if (bRebuilding)
{
if (selectedNodeIndex.length == 0)
{
prop_selectedNodeIndex = "0";
}
var node = getNodeFromIndex(selectedNodeIndex);
prop_selectedNodeIndex = "";
selectNode(node);
}
}
}
function buildTreeFromRoot()
{
treeviewNode = element.document.createElement("HTML");
var bodyNode = element.document.createElement("BODY");
var head = element.document.createElement("HEAD");
var base = element.document.createElement("BASE");
var path = null;
if (window.location.pathname != null)
{
var lastslash = window.location.pathname.lastIndexOf("/");
if (lastslash != -1)
path = window.location.pathname.substr(0, lastslash + 1);
else
path = window.location.pathname;
}
var protocol = window.location.protocol.toLowerCase();
base.href = window.location.protocol + (protocol != "mailto:" && protocol != "news:" ? "//" : "") + window.location.host + path;
head.appendChild(base);
treeviewNode.appendChild(head);
var kids = contentNode.children.tags("treenode");
if (kids[0] != undefined)
{
for (var i = 0; i < kids.length; i++)
{
kids[i].sibIndex = i;
var subtree = buildTree(kids[i], 0);
bodyNode.appendChild(subtree);
}
}
treeviewNode.appendChild(bodyNode);
treeviewNode.style.display = "block";
treeviewNode.subtree = bodyNode;
defaults.viewLink = treeviewNode.document;
setHiddenHelperValue();
g_bCreated = true;
}
function buildTree(root, level)
{
root.detachEvent("onclick", DefaultNodeOnClick);
root.attachEvent("onclick", DefaultNodeOnClick);
root.inheritedType = undefined;
root.nodetypeIndex = undefined;
if (!verifyBooleanAttribute(root, "expanded"))
root.setAttribute("expanded", false, 0);
if (!verifyBooleanAttribute(root, "checked"))
root.setAttribute("checked", false);
verifyBooleanAttribute(root, "checkBox");
var exp = root.getAttribute("expanded");
if (exp == null && level < element.getAttribute("ExpandLevel"))
{
root.setAttribute("expanded", true, 0);
exp = true;
}
if (root.getAttribute("type") != null)
root.setAttribute("type", root.getAttribute("type").toLowerCase(), 0);
if (root.getAttribute("childType") != null)
root.setAttribute("childType", root.getAttribute("childType").toLowerCase(), 0);
var collChildren = root.children.tags("treenode");
var iChildren = collChildren.length;
var expandable = getNodeAttribute(root, "expandable");
if (expandable == null && root.getAttribute("TreeNodeSrc") != null)
expandable = "checkOnce";
if (root.getAttribute("_bound") != "binding")
{
var subtree = generateItem(root, iChildren > 0 || (expandable == "always" || (expandable == "checkOnce" && root.getAttribute("checkedExpandable") != true)) ? "parent" : "child");
if (root.getAttribute("expanded") == true)
{
for (var i = 0; i < iChildren; i++)
{
collChildren[i].sibIndex = i;
subtree.appendChild(buildTree(collChildren[i], level + 1));
}
}
saveSubtree(root, subtree);
}
return root.subtree;
}
function saveSubtree(el, subtree)
{
if (el.getAttribute("subtree") == null)
el.subtree = subtree;
else {
el.subtree.replaceNode(subtree);
el.subtree = subtree;
}
}
function calcJunction(el)
{
var elParent = el.parentElement;
var collChildren = elParent.children.tags("treenode");
if (elParent.tagName == "treeview"  && collChildren[0] == el)
{
if (collChildren.length > 1)
return ('F');
else
return ('R');
}
else
{
if (collChildren[collChildren.length - 1] == el)
{
return ('L');
}
else
{
return ('T');
}
}
}
function generateItem(el, nodeClass)
{
var image;
var plusminusNode;
var elAnchor;
var expImgUrl = getNodeAttribute(el, "ExpandedImageUrl");
var imgUrl = getNodeAttribute(el, "ImageUrl");
var node = el.document.createElement("DIV");
var cJunction;
var junctionNode;
var str;
node.className = nodeClass;
node.treenode = el;
node.noWrap = true;
node.style.display = "block";
if (nodeClass == "child" && el.getAttribute("expanded") == true)
el.setAttribute("expanded", false, 0);
cJunction = calcJunction(el);
junctionNode = generateJunctionNode(el, cJunction, nodeClass);
node.appendChild(junctionNode);
addLinesAndWhitespace(node, el, junctionNode);
if (getNodeAttribute(el, "checkBox") == true)
{
var cb = createCheckBox(el);
node.appendChild(cb);
}
elAnchor = el.document.createElement("<A tabIndex=-1>");
elAnchor.onclick = nodePlusMinusClick;
junctionNode.applyElement(elAnchor, "outside");
elAnchor = el.document.createElement("<A tabIndex=-1>");
str = getNodeAttribute(el, "NavigateUrl");
if (str != null && str != "")
{
elAnchor.href = str;
}
str = getNodeAttribute(el, "Target");
if (str != null)
elAnchor.target = str;
elAnchor.onclick = nodeClick;
elAnchor.oncontextmenu = contextmenu;
elAnchor.onmousedown = mousedown;
elAnchor.onmouseup = mouseup;
node.insertBefore(elAnchor);
imageSrc = (nodeClass == "parent" && el.getAttribute("expanded") == true && expImgUrl != null ? expImgUrl : imgUrl);
if (imageSrc != null && imageSrc != undefined)
{
image = el.document.createElement("<IMG align='absmiddle' border='0' class='icon' name='nodeicon'>");
image.src = imageSrc;
image.style.cssText = g_styles["icon"];
elAnchor.appendChild(image);
}
var textNode = generateTextNode(el);
elAnchor.appendChild(textNode);
elAnchor.onmouseenter = mOver;
elAnchor.onmouseleave = mOut;
return node;
}
function createCheckBox(el)
{
var form = el.document.createElement("<FORM style='display:inline' name='fcb'>");
var bChecked = el.getAttribute("checked");
var cb = el.document.createElement("<INPUT style='display:inline' type=checkbox name='cb'" + (bChecked ? " checked " : " ") + "/>");
cb.onclick = checkboxClick;
form.appendChild(cb);
return form;
}
function generateJunctionNode(el, cJunction, nodeClass)
{
var imageSrc;
var junctionNode;
var systemImagesPath = element.getAttribute("systemImagesPath");
if (element.getAttribute("showLines") != false)
{
imageSrc = systemImagesPath;
switch (cJunction)
{
case 'L':
imageSrc += "L";
break;
case 'T':
imageSrc += "T";
break;
case 'R':
imageSrc += "R";
break;
case 'F':
imageSrc += "F";
break;
default:
alert("Invalid junction type: " + cJunction);
return null;
break;
}
if (nodeClass == "parent" && element.getAttribute("showPlus") != false )
{
if (el.getAttribute("expanded") == true)
imageSrc += "minus.gif";
else
imageSrc +="plus.gif";
}
else
imageSrc += ".gif";
}
else
{
if (nodeClass == "parent" && element.getAttribute("showPlus") != false)
{
if (el.getAttribute("expanded") == true)
imageSrc = systemImagesPath + "minus.gif";
else
imageSrc = systemImagesPath + "plus.gif";
}
else
{
imageSrc = systemImagesPath + "white.gif";
}
}
junctionNode = element.document.createElement("<IMG align='absmiddle' border='0' class='icon' name='junction'>");
junctionNode.src = imageSrc;
return junctionNode;
}
function addLinesAndWhitespace(node, el, junctionNode)
{
var elWalk = el.parentElement;
var elInsertBefore = junctionNode;
var systemImagesPath = element.getAttribute("systemImagesPath");
if (element.getAttribute("showLines") != false)
{
while (elWalk && elWalk.tagName.toLowerCase() == "treenode")
{
var nextSib = elWalk.nextSibling;
while (nextSib != null && nextSib.nodeType == 3)
nextSib = nextSib.nextSibling;
var imageSrc;
var image;
if (nextSib != null && nextSib.tagName.toLowerCase() == "treenode")
imageSrc = systemImagesPath + "I.gif";
else
imageSrc = systemImagesPath + "white.gif";
image = el.document.createElement("<IMG align='absmiddle' border='0'>");
image.src = imageSrc;
elInsertBefore = node.insertBefore(image, elInsertBefore);
elWalk = elWalk.parentElement;
}
}
else
{
var strIndex = getNodeIndex(el);
if (strIndex.indexOf(".") != -1)
{
if (element.getAttribute("Indent") != null)
node.style.marginLeft = element.getAttribute("Indent");
}
}
}
function generateTextNode(el)
{
var textNode = el.document.createElement("<SPAN id=_tntext tabIndex=-1 style='display:inline; height=100%'>");
if (el.getAttribute("Text") != null)
{
textNode.innerHTML = el.getAttribute("Text");
}
else
{
var iChild = 0;
while (iChild < el.childNodes.length)
{
if (el.childNodes[iChild].nodeType == 3 || el.childNodes[iChild].tagName.toLowerCase() != "treenode")
{
var oClone = el.childNodes[iChild].cloneNode(true);
textNode.appendChild(oClone);
}
iChild++;
}
}
textNode.className = "defaultstyle";
var defStyle = cascadeStyle(el, "defaultstyle");
textNode.style.cssText = defStyle;
return textNode;
}
function updateTree(el)
{
if (el.getAttribute("expanded") == true)
{
var i = 0;
var coll = el.children.tags("treenode");
var bRebuild = true;
if (coll.length > 0 && coll(0).getAttribute("subtree") != null)
{
bRebuild = false;
for (var i = 0; i < coll.length; i++)
{
if (coll(i).subtree == null)
{
bRebuild = true;
break;
}
coll(i).subtree.style.display = "block";
}
}
if (bRebuild)
{
buildTree(el, getNodeLevel(el));
reselectNode(el);
}
}
else
{
var collChildren = el.children.tags("treenode");
for (var i = 0; i < collChildren.length; i++)
{
collChildren(i).subtree.style.display = "none";
}
var index = getNodeIndex(el);
if (selectedNodeIndex.length > index.length && selectedNodeIndex.substr(0,index.length) == index)
{
selectNode(el);
}
else if (selectedNodeIndex == index)
changeIcon(el, "SelectedImageUrl");
if (HoverNodeIndex.length >= index.length && HoverNodeIndex.substr(0, index.length) == index)
{
if (selectedNodeIndex != index)
{
if (HoverNodeIndex != index)
{
UnhoverNode(getNodeFromIndex(HoverNodeIndex));
HoverNode(el);
}
}
else
UnhoverNode(getNodeFromIndex(HoverNodeIndex));
}
}
setHiddenHelperValue();
}
function cascadeStyle(el, att)
{
var str = g_styles[att];
var strStyle = element.getAttribute(att);
if (strStyle != null)
str = str + ";" + strStyle;
strStyle = getNodeTypeAttribute(el, att);
if (strStyle != null)
str = str + ";" + strStyle;
strStyle = el.getAttribute(att);
if (strStyle != null)
str = str + ";" + strStyle;
return str;
}
function getNodeTypeAttribute(el, att)
{
var _nodetype = getNodeTypeObject(el);
if (_nodetype != null)
return _nodetype.getAttribute(att);
return null;
}
function getNodeAttribute(el, att)
{
var strReturn;
strReturn = el.getAttribute(att);
if (strReturn != null)
return strReturn;
strReturn = getNodeTypeAttribute(el, att);
if (strReturn != null)
return strReturn;
return element.getAttribute(att);
}
function navigateNode(el)
{
var url = getNodeAttribute(el, "NavigateUrl");
if (url != null && url != "")
{
var target = getNodeAttribute(el, "Target");
if (target == null || target == "_self")
{
window.open(url, "_self");
return true;
}
else
window.open(url, target);
}
return false;
}
function checkboxClick()
{
if (g_bInteractive == false)
return;
var el = this.parentElement.parentElement.treenode;
el.checked = this.checked;
event.cancelBubble = true;
var evt = createEventObject();
evt.treenodeIndex = getNodeIndex(el);
g_nodeClicked = el;
_tvevtCheck.fire(evt);
fireQueuedEvents();
}
function nodeClick()
{
if (g_bInteractive == false)
return;
var el = this.parentElement.treenode;
if (doNodeClick(el) == true)
{
if (element.getAttribute("selectExpands") == true)
doNodePlusMinusClick(el);
fireQueuedEvents();
}
}
function contextmenu()
{
event.cancelBubble = true;
e = element.document.createEventObject(event);
e.treenodeIndex = getNodeIndex(this.parentElement.treenode);
event.returnValue = element.fireEvent("oncontextmenu", e);
}
function mousedown()
{
if (event.button & 1)
g_bMouseDown = true;
}
function mouseup()
{
g_bMouseDown = false;
}
function nodePlusMinusClick()
{
if (g_bInteractive == false)
return;
var el = this.parentElement.treenode;
if (doNodePlusMinusClick(el) == true)
fireQueuedEvents();
}
function doNodeClick(el)
{
if (g_bInteractive == false)
return;
g_nodeClicked = el;
event.cancelBubble = true;
el.fireEvent("onclick");
element.fireEvent("onclick", event);
if (getNodeAttribute(el, "NavigateUrl") != null)
{
var target = getNodeAttribute(el, "Target");
if (target == null || target.toLowerCase() == "_self")
return false;
}
selectNode(el);
return true;
}
function doNodePlusMinusClick(el)
{
if (g_bInteractive == false)
return false;
event.cancelBubble = true;
g_nodeClicked = el;
if (el.getAttribute("_bound") == null && el.getAttribute("TreeNodeSrc") != null)
{
g_databindInfo.expand = true;
databindNode(el);
return true;
}
else
return finishNodePlusMinusClick(el);
}
function finishNodePlusMinusClick(el)
{
var exp = getNodeAttribute(el, "expandable");
if (exp == null && el.getAttribute("TreeNodeSrc") != null)
exp = "checkOnce";
if (el.children.tags("treenode").length > 0 || exp == "always" || (exp == "checkOnce" && el.getAttribute("checkedExpandable") != true))
{
el.setAttribute("expanded", !el.getAttribute("expanded"), 0);
if (exp == "checkOnce")
el.checkedExpandable = true;
var evt = createEventObject();
evt.treenodeIndex = getNodeIndex(el);
var eventToFire = changeJunctionImage(el);
eventToFire.fire(evt);
updateTree(el);
if (el.getAttribute("expanded") == true && el.children.tags("treenode").length == 0 && element.getAttribute("onfirequeuedevents") != null)
addStatusNode(el, "Retrieving nodes...");
return true;
}
return false;
}
function changeJunctionImage(el)
{
var icon1 = el.subtree.all("junction",0);
if (el.getAttribute("expanded") == true)
{
if (icon1 != null)
icon1.src = icon1.src.replace(/plus/, "minus");
if (selectedNodeIndex != getNodeIndex(el) || getNodeAttribute(el, "selectedimageurl") == null)
changeIcon(el, "ExpandedImageUrl");
return _tvevtExpand;
}
else
{
if (icon1 != null)
icon1.src = icon1.src.replace(/minus/, "plus");
if (selectedNodeIndex != getNodeIndex(el))
changeIcon(el, "ImageUrl");
return _tvevtCollapse;
}
}
function DefaultNodeOnClick()
{
event.cancelBubble = true;
}
function getClickedNodeIndex()
{
if (g_nodeClicked != null)
return getNodeIndex(g_nodeClicked);
else
return null;
}
function getNodeLevel(node)
{
var level = 0;
while (node.parentElement.tagName.toLowerCase() == "treenode")
{
node = node.parentElement;
level++;
}
return level;
}
function getNodeIndex(node)
{
var strIndex = "";
if (node != null && node.getAttribute("sibIndex") != null)
{
strIndex = node.sibIndex.toString();
while (node.parentElement.tagName.toLowerCase() == "treenode")
{
node = node.parentElement;
strIndex = node.sibIndex + "." + strIndex;
}
}
return strIndex;
}
function getNodeFromIndex(strIndex)
{
if (strIndex != null && strIndex != undefined && strIndex.length != 0)
{
var a = strIndex.split(".");
var i = 0;
var node = contentNode;
while (i < a.length)
{
var coll = node.children.tags("treenode");
if (coll == null || coll.length < (a[i] - 0) + 1)
{
return null;
}
node = coll.item(a[i++] - 0);
}
return node;
}
else
{
return null;
}
}
function getNextVisibleNode(node)
{
var next = node;
if (node.getAttribute("expanded") == true)
{
next = node.children[0];
while (next != null && next != undefined && next.nodeName.toLowerCase() != "treenode")
next = next.nextSibling;
if (next)
return next;
}
next = node.nextSibling;
while (next != null && next != undefined && next.nodeName.toLowerCase() != "treenode")
next = next.nextSibling;
if (next != null)
return next;
next = node.parentElement;
while ((next.nextSibling == null || next.nextSibling == undefined) && next.nodeName.toLowerCase() == "treenode")
{
next = next.parentElement;
}
if (next.nextSibling != null && next.nextSibling != undefined && next.nextSibling.nodeName.toLowerCase() == "treenode")
return next.nextSibling;
else
return null;
}
function getPreviousVisibleNode(node)
{
var prev = node;
prev = node.previousSibling;
while (prev != null && prev != undefined && prev.nodeName.toLowerCase() != "treenode")
prev = prev.previousSibling;
if (prev)
{
if (prev.getAttribute("expanded") == true)
{
var lastChild = prev;
while (lastChild != node && lastChild != null)
{
prev = lastChild;
lastChild = getNextVisibleNode(prev);
}
}
return prev;
}
if (node.parentElement.nodeName.toLowerCase() == "treenode")
return node.parentElement;
else
return null;
}
function setHiddenHelperValue()
{
window.document.all(element.HelperID).value = (g_bFocus ? "1" : "0") + "|" + HoverNodeIndex + "|" + g_strQueuedEvents;
}
function scrollTree(tnode)
{
var node = tnode.subtree.all.item("_tntext", 0);
var rc = node.getBoundingClientRect();
var elRc = element.getBoundingClientRect();
if (rc.top < 0)
element.scrollTop += rc.top;
else if (rc.bottom > element.offsetHeight)
element.scrollTop += (rc.bottom - element.offsetHeight);
if (g_bFocus)
{
if (elRc.top + rc.top < element.document.body.clientTop)
node.scrollIntoView(true);
else if (elRc.top + rc.bottom > element.document.body.clientHeight)
node.scrollIntoView(false);
}
}
function getInheritedType(el)
{
if (el.inheritedType === undefined)
{
var parentNode = el.parentElement;
el.inheritedType = parentNode.getAttribute("childType");
var tagname = parentNode.tagName.toLowerCase();
if (el.inheritedType == null && tagname != "treeview")
{
var _parenttype = getNodeTypeObject(parentNode);
if (_parenttype != null)
{
el.inheritedType = _parenttype.getAttribute("childType");
}
if (el.inheritedType == null && tagname == "treenode")
{
el.inheritedType = getInheritedType(parentNode);
}
}
if (el.inheritedType == null)
el.inheritedType = element.getAttribute("childType");
}
return el.inheritedType;
}
function getNodeTypeObject(el)
{
if (el.nodetypeIndex == undefined)
{
var theType = el.getAttribute("type");
if (theType == null)
theType = getInheritedType(el);
if (theType == null)
return null;
theType = theType.toLowerCase();
var i = 0;
var len = element.nodeTypes.length;
while (i < len && el.nodetypeIndex == undefined)
{
if (element.nodeTypes[i].getAttribute("type") == theType)
{
el.nodetypeIndex = i;
}
i++;
}
}
return element.nodeTypes[el.nodetypeIndex];
}
function replaceJunctionNode(node)
{
if (node.subtree == null)
return;
var cJunction = calcJunction(node);
var exp = node.getAttribute("Expandable");
if (exp == null && node.getAttribute("TreeNodeSrc") != null)
exp = "checkOnce";
var junctionNode = generateJunctionNode(node, cJunction, node.children.length > 0 || (exp == "always" || (exp == "checkOnce" && node.getAttribute("checkedExpandable") != true)) ? "parent" : "child");
var oldNode = node.subtree.all("junction", 0);
oldNode.replaceNode(junctionNode);
}
function addStatusNode(el, str)
{
if (el.subtree != null && el.subtree.all.item("_fetch", 0) != null)
return;
var fetchNode =  el.document.createElement("<DIV id=_fetch>");
var imageNode = el.document.createElement("<IMG align='absmiddle' border='0'>");
imageNode.src = element.getAttribute("systemimagespath") + "white.gif";
fetchNode.appendChild(imageNode);
var junctionNode = generateJunctionNode(null, 'L', "child");
fetchNode.appendChild(junctionNode);
addLinesAndWhitespace(fetchNode, el == element ? contentNode : el, junctionNode);
var textNode = el.document.createElement("<SPAN id=_tntext tabIndex=-1 style='display:inline; height=100%'>");
textNode.innerText = str;
textNode.className = "defaultstyle";
var defStyle;
if (el == element)
defStyle = g_styles["defaultstyle"] + ";" + element.getAttribute("defaultstyle");
else
defStyle = cascadeStyle(el, "defaultstyle");
textNode.style.cssText = defStyle;
fetchNode.appendChild(textNode);
if (el == element)
{
fetchNode.style.display = "block";
defaults.viewLink = fetchNode.document;
}
else
{
el.subtree.appendChild(fetchNode);
}
}
function databindNode(el)
{
addStatusNode(el, "Retrieving nodes...");
el._bound = "binding";
var xslsrc = el.getAttribute("TreeNodeXslSrc");
var src = el.getAttribute("TreeNodeSrc");
g_databindInfo.el = el;
g_databindInfo.transform = null;
g_databindInfo.island = null;
if (el == contentNode)
g_bNodesReady = false;
if (src == null)
return;
if (xslsrc != null)
{
g_databindInfo.transform = element.document.all(xslsrc);
if (g_databindInfo.transform == null)
{
g_databindInfo.transform = new ActiveXObject("Msxml2.DOMDocument");
g_databindInfo.transform.async = false;
if (!g_databindInfo.transform.loadXML(xslsrc))
g_databindInfo.transform.load(xslsrc);
}
else
g_databindInfo.transform = g_databindInfo.transform.XMLDocument;
}
g_databindInfo.island = element.document.all(src);
if (g_databindInfo.island == null)
{
g_databindInfo.island = element.document.createElement("<XML>");
g_databindInfo.island.async = false;
if (!g_databindInfo.island.loadXML(src))
{
g_databindInfo.island.onreadystatechange=finishDatabindingNode;
g_databindInfo.island.async = true;
g_databindInfo.island.load(src);
}
else
finishDatabindingNode(true);
}
}
function finishDatabindingNode(bReady)
{
if (bReady != true && (g_databindInfo.island == null || g_databindInfo.island.readyState != "interactive"))
return;
if (g_databindInfo.island.xml == "")
{
var fetch;
var event = createEventObject();
if (g_databindInfo.el == element)
event.treenodeIndex = null;
else
event.treenodeIndex = getNodeIndex(g_databindInfo.el);
event.reason = 2;
_tvevtDataSetComplete.fire(event);
if (g_databindInfo.el == element)
fetch = defaults.viewLink.all.item("_fetch", 0);
else
fetch = g_databindInfo.el.subtree.all.item("_fetch", 0);
if (fetch != null)
{
var tntext = fetch.all.item("_tntext", 0);
tntext.innerHTML = "<B>Error loading XML file " + g_databindInfo.el.getAttribute('TreeNodeSrc') + "</B>";
}
g_databindInfo.el._bound = null;
g_databindInfo.el = null;
return;
}
if (g_databindInfo.transform != null)
{
var html = g_databindInfo.island.transformNode(g_databindInfo.transform);
g_databindInfo.island = element.document.createElement("<XML>");
g_databindInfo.island.loadXML(html);
}
var container = g_databindInfo.island.selectSingleNode("TREENODES");
if (container == null)
return;
var child = container.firstChild;
var html = "";
while (child != null)
{
if (child.nodeName.toLowerCase() == "treenode")
html += child.xml;
child = child.nextSibling;
}
g_databindInfo.el._bound = "complete";
html = html.replace(/(<\/?)(treenode)/gi, "$1" + element.scopeName + ":$2");
if (g_databindInfo.el == element)
{
contentNode.innerHTML += html;
g_bNodesReady = true;
tryToBuildTreeFromRoot();
}
else
{
g_databindInfo.el.innerHTML += html;
buildTree(g_databindInfo.el, getNodeLevel(g_databindInfo.el));
if (g_databindInfo.expand == true)
{
g_databindInfo.expand = false;
finishNodePlusMinusClick(g_databindInfo.el);
}
else
{
reselectNode(g_databindInfo.el);
}
}
var event = element.document.createEventObject();
if (g_databindInfo.el == element)
event.treenodeIndex = null;
else
event.treenodeIndex = getNodeIndex(g_databindInfo.el);
event.reason = 0;
_tvevtDataSetComplete.fire(event);
g_databindInfo.el = null;
}
function databindTypes()
{
var src = element.getAttribute("TreeNodeTypeSrc");
if (src == null)
return;
g_bTypesReady = false;
g_typeIsland = element.document.all(src);
if (g_typeIsland == null)
{
g_typeIsland = element.document.createElement("<XML>");
g_typeIsland.onreadystatechange = finishDatabindingTypes;
if (!g_typeIsland.loadXML(src))
g_typeIsland.load(src);
}
}
function finishDatabindingTypes()
{
if (g_typeIsland.readyState != "interactive")
return;
var container = g_typeIsland.selectSingleNode("TREENODETYPES");
if (container == null)
return;
var child = container.firstChild;
var html = "";
while (child != null)
{
if (child.nodeName.toLowerCase() == "treenodetype")
html += child.xml;
child = child.nextSibling;
}
html = html.replace(/(<\/?)(treenodetype)/gi, "$1" + element.scopeName + ":$2");
typesNode = element.document.createElement("DIV");
typesNode.innerHTML = html;
element.nodeTypes = typesNode.children.tags("TREENODETYPE");
verifyTypeValues();
g_bTypesReady = true;
tryToBuildTreeFromRoot();
}
function verifyExpandableValue(value)
{
var lval = value.toLowerCase();
switch (lval)
{
case "auto":
case "checkonce":
case "always":
return true;
default:
return false;
break;
}
}
function verifyBooleanAttribute(node, att)
{
var value = node.getAttribute(att);
if (value == null)
return false;
var boolval = makeBoolean(value);
if (value == boolval)
return true;
node.setAttribute(att, boolval == null ? false : boolval, 0);
return (boolval != null);
}
function makeBoolean(value)
{
if (value == true || value == false)
return value;
if (value == null)
return null;
var lval = value.toLowerCase();
switch (lval)
{
case "true":
return true;
case "false":
return false;
default:
return null;
}
}
function verifyTypeValues()
{
var len = element.nodeTypes.length;
for (var i = 0; i < len; i++)
{
var str = element.nodeTypes[i].getAttribute("type");
if (str != null)
element.nodeTypes[i].setAttribute("type", str.toLowerCase(), 0);
verifyBooleanAttribute(element.nodeTypes[i], "expanded");
verifyBooleanAttribute(element.nodeTypes[i], "checkBox");
}
}
function getNodeTypeHtml()
{
var html = "";
for (var i = 0; i < element.nodeTypes.length; i++)
{
html += element.nodeTypes[i].outerHTML;
}
return html;
}
function getDefaultStyle()
{
return prop_defaultStyle;
}
function setDefaultStyle(value)
{
if (prop_defaultStyle == value)
return;
if (typeof value == "string")
{
prop_defaultStyle = value;
if (g_bCreated)
{
modifyNodesByType(contentNode, null, "defaultstyle")
_tvpropDefaultStyle.fireChange();
}
}
}
function getHoverStyle()
{
return prop_hoverStyle;
}
function setHoverStyle(value)
{
if (prop_hoverStyle == value)
return;
if (typeof value == "string")
{
prop_hoverStyle = value;
if (g_bCreated)
{
modifyNodesByType(contentNode, null, "hoverstyle")
_tvpropHoverStyle.fireChange();
}
}
}
function getSelectedStyle()
{
return prop_selectedStyle;
}
function setSelectedStyle(value)
{
if (prop_selectedStyle == value)
return;
if (typeof value == "string")
{
prop_selectedStyle = value;
if (g_bCreated)
{
modifyNodesByType(contentNode, null, "selectedstyle")
_tvpropSelectedStyle.fireChange();
}
}
}
function getChildType()
{
return prop_childType;
}
function setChildType(value)
{
if (prop_childType != value)
{
prop_childType = value;
if (g_bCreated)
{
var col = contentNode.children.tags("treenode");
for (var i = 0; i < col.length; i++)
buildTree(col[i], 0);
_tvpropChildType.fireChange();
}
}
}
function getImageUrl()
{
return prop_imageUrl;
}
function setImageUrl(value)
{
if (prop_imageUrl != value)
{
prop_imageUrl = value;
if (g_bCreated)
{
modifyNodesInheritingFromRoot(contentNode, "imageurl", value);
_tvpropImageUrl.fireChange();
}
}
}
function getSelectedImageUrl()
{
return prop_selectedImageUrl;
}
function setSelectedImageUrl(value)
{
if (prop_selectedImageUrl != value)
{
prop_selectedImageUrl = value;
if (g_bCreated)
{
modifyNodesInheritingFromRoot(contentNode, "selectedimageurl", value);
_tvpropSelectedImageUrl.fireChange();
}
}
}
function getExpandedImageUrl()
{
return prop_expandedImageUrl;
}
function setExpandedImageUrl(value)
{
if (prop_expandedImageUrl != value)
{
prop_expandedImageUrl = value;
if (g_bCreated)
{
modifyNodesInheritingFromRoot(contentNode, "expandedimageurl", value);
_tvpropExpandedImageUrl.fireChange();
}
}
}
function getTarget()
{
return prop_target;
}
function setTarget(value)
{
if (prop_target != value)
{
prop_target = value;
if (g_bCreated)
{
modifyNodesInheritingFromRoot(contentNode, "target", value);
_tvpropTarget.fireChange();
}
}
}
function getTreeNodeSrc()
{
return prop_treeNodeSrc;
}
function setTreeNodeSrc(value)
{
if (prop_treeNodeSrc != value)
{
prop_treeNodeSrc = value;
if (g_bCreated)
{
if (typesNode == null)
typesNode = element.document.createElement("DIV");
typesNode.innerHTML = getNodeTypeHtml();
element.nodeTypes = typesNode.children.tags("TREENODETYPE");
treeviewNode.subtree.removeNode(true);
contentNode.innerHTML = "";
databindNode(element);
_tvpropTreeNodeSrc.fireChange();
}
}
}
function getTreeNodeXslSrc()
{
return prop_treeNodeXslSrc;
}
function setTreeNodeXslSrc(value)
{
if (prop_treeNodeXslSrc != value)
{
prop_treeNodeXslSrc = value;
if (g_bCreated)
{
if (typesNode == null)
typesNode = element.document.createElement("DIV");
typesNode.innerHTML = getNodeTypeHtml();
element.nodeTypes = typesNode.children.tags("TREENODETYPE");
contentNode.innerHTML = "";
databindNode(element);
_tvpropTreeNodeXslSrc.fireChange();
}
}
}
function getSelectExpands()
{
return prop_selectExpands;
}
function setSelectExpands(value)
{
var boolval = makeBoolean(value)
if (boolval != null && boolval != prop_selectExpands)
{
prop_selectExpands = value;
if (g_bCreated)
_tvpropSelectExpands.fireChange();
}
}
function getExpandLevel()
{
return prop_expandLevel;
}
function setExpandLevel(value)
{
if (prop_expandLevel != value && typeof value == "number")
{
prop_expandLevel = value;
if (g_bCreated)
{
expandNodes(contentNode, value + 1);
_tvpropExpandLevel.fireChange();
}
}
}
function getAutoSelect()
{
return prop_autoSelect;
}
function setAutoSelect(value)
{
var boolval = makeBoolean(value)
if (boolval != null && boolval != prop_autoSelect)
{
prop_autoSelect = value;
if (g_bCreated)
_tvpropAutoSelect.fireChange();
}
}
function getTreeNodeTypeSrc()
{
return prop_treeNodeTypeSrc;
}
function setTreeNodeTypeSrc(value)
{
if (prop_treeNodeTypeSrc != value)
{
element.nodeTypes = null;
prop_treeNodeTypeSrc = value;
if (g_bCreated)
{
databindTypes();
_tvpropTreeNodeTypeSrc.fireChange();
}
}
}
function getShowLines()
{
return prop_showLines;
}
function setShowLines(value)
{
var boolval = makeBoolean(value);
if (prop_showLines != boolval && boolval != null)
{
prop_showLines = boolval;
if (g_bCreated)
{
buildTreeFromRoot();
_tvpropShowLines.fireChange();
}
}
}
function getShowPlus()
{
return prop_showPlus;
}
function setShowPlus(value)
{
var boolval = makeBoolean(value);
if (prop_showPlus != boolval && boolval != null)
{
prop_showPlus = boolval;
if (g_bCreated)
{
modifyNodesByType(contentNode, null, "_showplus");
_tvpropShowPlus.fireChange();
}
}
}
function getIndent()
{
return prop_indent;
}
function setIndent(value)
{
if (prop_indent != value)
{
if (typeof value == "string")
{
var i = parseInt(value);
if (i == NaN)
return;
else
prop_indent = i;
}
else if (typeof value == "number")
prop_indent = value;
else
return;
if (g_bCreated)
{
if (getShowLines() != true)
modifyNodesByType(contentNode, null, "_indent");
_tvpropShowLines.fireChange();
}
}
}
function getSelectedNodeIndex()
{
return prop_selectedNodeIndex;
}
function setSelectedNodeIndex(value)
{
if (prop_selectedNodeIndex != value && typeof value == "string")
{
if (value.length == 0)
return;
if (value.search(/[^0-9.]/) != -1)
return;
if (value[0] == '.')
return;
if (value.indexOf("..") != -1)
return;
if (g_bCreated)
{
var node = getNodeFromIndex(value);
if (node != null && node.subtree != null)
{
selectNode(node);
_tvpropSelectedNodeIndex.fireChange();
}
}
else
prop_selectedNodeIndex = value;
}
}
function getSystemImagesPath()
{
return prop_systemImagesPath;
}
function setSystemImagesPath(value)
{
if (prop_systemImagesPath != value && typeof value == "string")
{
prop_systemImagesPath = value;
if (g_bCreated)
{
buildTreeFromRoot();
_tvpropSystemImagesPath.fireChange();
}
}
}
function expandNodes(root, level)
{
if (root != contentNode)
{
var exp = root.getAttribute("expanded");
if (exp != true)
modifyNode(root, "expanded", true, false);
}
if (level > 0)
{
var col = root.children.tags("treenode");
for (var i = 0; i < col; i++)
{
expandNodes(root, level - 1);
}
}
}
function getTreeNodeType(key)
{
var tnt = null;
var len = element.nodeTypes.length;
if (typeof key == "number")
{
if (key >= 0 && key < len)
tnt = element.nodeTypes[key];
}
else
{
for (var i = 0; i < len; i++)
{
var temp = element.nodeTypes[i];
if (temp.getAttribute("Type") == key)
{
tnt = temp;
break;
}
}
}
if (tnt != null)
return private_getTreeNodeType(tnt);
else
return null;
}
function createTreeNodeType()
{
var realtnt = element.document.createElement("treenodetype");
return private_getTreeNodeType(realtnt);
}
function private_getTreeNodeType(tnt)
{
var obj = new Object();
obj.addTo = function(tree)
{
if (tree.nodeTypes == null || tree.nodeTypes.length == 0)
tree.nodeTypes = new Array(tnt);
else
tree.nodeTypes[tree.nodeTypes.length - 1].insertAdjacentElement("afterEnd", tnt);
modifyNodesByType(contentNode, tnt.getAttribute("type"), "type");
}
obj.remove = function(bRedraw) { private_removeTreeNodeType(tnt, bRedraw); };
obj.getAttribute = function(name) { return private_getNodeTypeAttribute(tnt, name); };
obj.setAttribute = function(name, value) { private_setNodeTypeAttribute(tnt, name, value); };
return obj;
}
function addTreeNodeType(tnt)
{
tnt.addTo(element);
}
function private_removeTreeNodeType(tnt, bRedraw)
{
var name = tnt.getAttribute("Type");
tnt.removeNode(false);
if (bRedraw != false)
{
modifyNodesByType(contentNode, null, "type");
}
else
{
modifyNodesByType(contentNode, null, "_nodetypeIndex");
}
}
function modifyNodesByType(node, type, att)
{
if (node != contentNode)
{
if (node.subtree == null)
return;
if (type == null || getNodeAttribute(node, "Type") == type)
{
modifyNode(node, att, null, type);
if (att == "type" || att == "childtype")
return;
}
}
var col = node.children.tags("treenode");
for (var i = 0; i < col.length; i++)
{
modifyNodesByType(col[i], type, att);
}
}
function modifyNodesInheritingFromRoot(root, att, value)
{
if (root != contentNode)
{
if (root.subtree == null)
return;
if (inheritsFromRoot(root, att))
{
modifyNode(root, att, value, null);
if (att == "type" || att == "childtype")
return;
}
}
var col = root.children.tags("treenode");
for (var i = 0; i < col.length; i++)
{
modifyNodesInheritingFromRoot(col[i], att, value);
}
}
function inheritsFromRoot(node, att)
{
if (node.getAttribute(att) != null)
return false;
if (getNodeTypeAttribute(node, att) != null)
return false;
return true;
}
function private_getNodeTypeAttribute(tnt, name)
{
return tnt.getAttribute(name.toLowerCase());
}
function private_setNodeTypeAttribute(tnt, name, value)
{
var lname = name.toLowerCase();
if (lname == "outerhtml")
return;
var old = tnt.getAttribute(name, value);
tnt.setAttribute(name, value, 0);
if (tnt.parentElement == null)
return;
switch (lname)
{
case "text":
case "innertext":
break;
case "expandable":
if (verifyExpandableValue(value) == true)
modifyNodesByType(contentNode, tnt.getAttribute("type"), lname);
else
tnt.setAttribute(name, old, 0);
break;
default:
modifyNodesByType(contentNode, tnt.getAttribute("type"), lname);
break;
}
}
function createTreeNode()
{
var realNode = element.document.createElement("treenode");
return private_getTreeNode(realNode);
}
function getTreeNode(index)
{
var node = getNodeFromIndex(index);
if (node == null)
return null;
return private_getTreeNode(node);
}
function private_getTreeNode(node)
{
var obj = new Object();
obj.addAt = function(index, newnode)
{
if (newnode._real != null)
private_addAt(node, index, newnode._real);
else
{
var temp = private_getTreeNode(node);
temp._real = node;
newnode.addTo(index, temp);
}
};
obj.addTo = function(index, parent)
{
if (parent._real != null)
private_addAt(parent._real, index, node);
else
{
var temp = private_getTreeNode(node);
temp._real = node;
parent.addAt(index, temp);
}
};
obj.add = function(newnode) { obj.addAt(node.children.tags("treenode").length, newnode); };
obj.remove = function() { private_remove(node); };
obj.getAttribute = function(name) { return private_getAttribute(node, name); };
obj.setAttribute = function(name, value) { private_setAttribute(node, name, value); };
obj._real = null;
obj.findAttribute = function(name) { return getNodeAttribute(node, name); };
return obj;
}
function addAt(index, node)
{
node.addTo(index, private_getTreeNode(contentNode));
}
function add(node)
{
node.addTo(contentNode.children.tags("treenode").length, private_getTreeNode(contentNode));
}
function private_addAt(parent, index, child)
{
var col = parent.children.tags("treenode");
var iCount = col.length;
if (index < 0 || index > iCount)
return;
var selectedNode = getNodeFromIndex(selectedNodeIndex);
if (index == iCount)
parent.appendChild(child);
else
{
col[index].insertAdjacentElement("beforeBegin", child);
}
child.sibIndex = index;
for (var i = index; i <= iCount; i++)
col[i].sibIndex = i;
var p = parent;
while (p != null && p.tagName.toLowerCase() == "treenode")
p = p.parentElement;
if (p != null && p.tagName.toLowerCase() != "treeview")
return;
if (parent.getAttribute("expanded") == true || parent == contentNode)
{
var disptree = buildTree(child, getNodeLevel(child));
if (index == iCount)
{
if (parent.subtree == null)
{
if (parent == contentNode)
buildTreeFromRoot();
else
parent.subtree = disptree;
}
else
{
if (parent == contentNode)
treeviewNode.subtree.appendChild(disptree);
else
parent.subtree.appendChild(disptree);
}
}
else
col[index + 1].subtree.insertAdjacentElement("beforeBegin", disptree);
}
if (iCount == 0)
{
if (parent != contentNode)
replaceJunctionNode(parent);
}
else if (index == iCount)
replaceJunctionNode(col[index - 1]);
else if (index == 0)
replaceJunctionNode(col[1]);
prop_selectedNodeIndex = getNodeIndex(selectedNode);
}
function private_remove(node)
{
if (node.parentElement == null)
return null;
var parent = node.parentElement;
var col = parent.children.tags("treenode");
var iCount = col.length;
var sibindex = node.sibIndex;
var selectedNode = getNodeFromIndex(selectedNodeIndex);
node.subtree.removeNode(true);
node.removeNode(true);
if (iCount == 1)
replaceJunctionNode(parent);
else if (sibindex != 0 && sibindex == iCount - 1)
buildTree(col[sibindex - 1], getNodeLevel(col[sibindex - 1]));
else if (sibindex == 0 && parent.tagName.toLowerCase() != "treenode")
replaceJunctionNode(col[0]);
for (var i = sibindex; i < col.length; i++)
col[i].sibIndex = i;
if (node == selectedNode)
{
prop_selectedNodeIndex = "";
if (iCount - 1 > sibindex)
selectNode(col[sibindex]);
else if (iCount > 1 && sibindex > 0)
selectNode(col[sibindex - 1]);
else
selectNode(parent);
}
else
{
prop_selectedNodeIndex = "";
selectNode(selectedNode);
}
return node;
}
function private_getAttribute(node, name)
{
return node.getAttribute(name.toLowerCase());
}
function private_setAttribute(node, name, value)
{
var lname = name.toLowerCase();
if (lname == "outerhtml")
return;
var old = node.getAttribute(name, value);
node.setAttribute(name, value, 0);
if (node.parentElement == null)
return;
if (node.subtree == null)
return;
modifyNode(node, lname, value, old);
}
function modifyNode(node, lname, value, old)
{
switch (lname)
{
case "defaultstyle":
case "hoverstyle":
case "selectedstyle":
case "style":
SetAnchorClass(node.subtree.all.item("_tntext", 0), lname);
break;
case "text":
case "innertext":
case "innerhtml":
var tntext = node.subtree.all.item("_tntext", 0);
var newText = generateTextNode(node);
tntext.replaceNode(newText);
break;
case "imageurl":
changeIcon(node, lname);
break;
case "selectedimageurl":
if (selectedNodeIndex == getNodeIndex(node))
changeIcon(node, lname);
break;
case "expandedimageurl":
if (node.getAttribute("Expanded") == true)
changeIcon(node, lname);
break;
case "type":
buildTree(node, getNodeLevel(node));
var temp = getNodeFromIndex(selectedNodeIndex);
prop_selectedNodeIndex = "";
selectNode(temp);
break;
case "childtype":
var col = node.children.tags("treenode");
for (i = 0; i < col.length; i++)
{
buildTree(col[i], getNodeLevel(col[i]));
var temp = getNodeFromIndex(selectedNodeIndex);
prop_selectedNodeIndex = "";
selectNode(temp);
}
break;
case "target":
var textnode = node.subtree.all("_tntext", 0);
textnode.parentElement.target = getNodeAttribute(node, lname);
break;
case "navigateurl":
var textnode = node.subtree.all("_tntext", 0);
textnode.parentElement.href = getNodeAttribute(node, lname);
break;
case "expandable":
if (verifyExpandableValue(value) == true)
replaceJunctionNode(node);
else
node.setAttribute(lname, old, 0);
break;
case "expanded":
if (verifyBooleanAttribute(node, lname) == false)
node.setAttribute(lname, old, 0);
else if (node.getAttribute(lname) != old)
{
node.setAttribute("expanded", !node.getAttribute("expanded"), 0);
doNodePlusMinusClick(node);
}
break;
case "checked":
if (verifyBooleanAttribute(node, lname) == false)
node.setAttribute(lname, old, 0);
else if (getNodeAttribute(node, "checkBox") == true && node.getAttribute(lname) != old)
{
var cb = node.subtree.all.item("cb", 0);
cb.setAttribute("checked", node.getAttribute(lname));
}
break;
case "checkbox":
if (verifyBooleanAttribute(node, lname) == false && node.getAttribute(lname) != null)
node.setAttribute(lname, old, 0);
else if (getNodeAttribute(node, "checkbox") == true)
{
var jn = node.subtree.all("junction", 0);
if (jn)
{
var cb = createCheckBox(node);
jn.parentElement.insertAdjacentElement("afterEnd", cb);
}
}
else
{
var cb = node.subtree.all("fcb", 0);
if (cb)
cb.removeNode(true);
}
break;
case "treenodesrc":
if (value != null)
{
col = node.children.tags("treenode");
for (var i = col.length - 1; i >= 0; i--)
{
if (col[i].subtree != null)
col[i].subtree.removeNode(true);
col[i].removeNode(true);
}
databindNode(node);
}
break;
case "_showplus":
replaceJunctionNode(node);
break;
case "_indent":
var strIndex = getNodeIndex(node);
if (strIndex.indexOf(".") != -1)
node.subtree.style.marginLeft = prop_indent;
break;
case "_nodetypeIndex":
node.nodetypeIndex = undefined;
node.inheritedType = undefined;
break;
}
}
</script>